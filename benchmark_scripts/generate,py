import random
import math
import time
from shapely.geometry import Polygon, MultiPolygon, Point, box
from shapely import wkt
import folium
from IPython.display import display, clear_output

## HELPER FUNCTIONS
def get_random_point_within_bbox(bbox):
    """Generate a random point within a bounding box."""
    min_x, min_y, max_x, max_y = bbox
    return random.uniform(min_x, max_x), random.uniform(min_y, max_y)

def generate_regular_polygon(center_x, center_y, radius, num_points):
    """Generate a regular polygon with the given center, radius, and number of points."""
    points = []
    for i in range(num_points):
        angle = 2 * math.pi * i / num_points
        x = center_x + radius * math.cos(angle)
        y = center_y + radius * math.sin(angle)
        points.append((x, y))
    # Close the polygon
    points.append(points[0])
    return points

def generate_random_polygon(bbox, num_points):
    """Generate a random polygon within the bounding box with the given number of points."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Generate random center point
    center_x = min_x + width / 2
    center_y = min_y + height / 2
    
    # Generate random points at varied distances around the center
    radius = min(width, height) / 2 * 0.8  # 80% of half the smallest dimension
    
    # Generate points around the center at varying distances
    points = []
    for i in range(num_points):
        angle = 2 * math.pi * i / num_points
        # Vary the radius a bit
        r = radius * random.uniform(0.5, 1.0)
        x = center_x + r * math.cos(angle)
        y = center_y + r * math.sin(angle)
        points.append((x, y))
    
    # Close the polygon
    points.append(points[0])
    return points

def generate_random_hole(polygon, min_radius_ratio=0.1, max_radius_ratio=0.4):
    """Generate a random hole within a polygon."""
    bbox = polygon.bounds
    min_x, min_y, max_x, max_y = bbox
    center_x = (min_x + max_x) / 2
    center_y = (min_y + max_y) / 2
    
    width = max_x - min_x
    height = max_y - min_y
    
    # Calculate hole size (smaller than the polygon)
    radius = min(width, height) / 2 * random.uniform(min_radius_ratio, max_radius_ratio)
    
    # Create a smaller polygon as a hole
    hole_points = generate_regular_polygon(center_x, center_y, radius, random.randint(4, 8))
    
    return hole_points

def create_polygon_with_area_percentage(bbox, percentage):
    """Create a polygon with a specific percentage of the bounding box area."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Calculate the scaling factor to achieve the desired area percentage
    scale_factor = math.sqrt(percentage)
    
    # Calculate the dimensions of the new polygon
    new_width = width * scale_factor
    new_height = height * scale_factor
    
    # Calculate the center of the bounding box
    center_x = (min_x + max_x) / 2
    center_y = (min_y + max_y) / 2
    
    # Calculate the coordinates of the new polygon
    new_min_x = center_x - new_width / 2
    new_min_y = center_y - new_height / 2
    new_max_x = center_x + new_width / 2
    new_max_y = center_y + new_height / 2
    
    # Create the new polygon
    return [(new_min_x, new_min_y), (new_min_x, new_max_y), 
            (new_max_x, new_max_y), (new_max_x, new_min_y), (new_min_x, new_min_y)]

def generate_concave_polygon(bbox, num_points=8):
    """Generate a concave polygon within the bounding box."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    center_x = min_x + width / 2
    center_y = min_y + height / 2
    
    # Generate basic polygon points
    points = []
    for i in range(num_points):
        angle = 2 * math.pi * i / num_points
        # Alternate between smaller and larger radius to create concavity
        r = min(width, height) / 2 * (0.8 if i % 2 == 0 else 0.4)
        x = center_x + r * math.cos(angle)
        y = center_y + r * math.sin(angle)
        points.append((x, y))
    
    # Close the polygon
    points.append(points[0])
    return points

def shift_polygon(polygon, x_shift, y_shift):
    """Shift a polygon by the given x and y distances."""
    return [(x + x_shift, y + y_shift) for x, y in polygon]

## GENERATOR FUNCTIONS FOR SPECIFIC CASES
def genCase1(bbox, num_points):
    """Case 1: Simple polygon with 3 or more points."""
    polygon = generate_random_polygon(bbox, num_points)
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in polygon])}))"

def genCase2(bbox, area_percentage=0.5):
    """Case 2: Simple polygon with varying area percentage of BBOX."""
    polygon = create_polygon_with_area_percentage(bbox, area_percentage)
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in polygon])}))"

def genCase3(bbox, holes=1):
    """Case 3: Simple polygon with one hole."""
    outer_ring = generate_random_polygon(bbox, 6)
    polygon = Polygon(outer_ring)
    
    # Generate hole
    hole = generate_random_hole(polygon)
    
    wkt_str = f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in outer_ring])}), "
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole])}))"
    
    return wkt_str

def genCase4(bbox, num_holes=2):
    """Case 4: Simple polygon with two or more holes."""
    outer_ring = generate_random_polygon(bbox, 8)
    polygon = Polygon(outer_ring)
    
    wkt_str = f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in outer_ring])})"
    
    # Generate multiple holes
    for i in range(num_holes):
        hole = generate_random_hole(polygon, 
                                   min_radius_ratio=0.1 + (i * 0.05), 
                                   max_radius_ratio=0.2 + (i * 0.05))
        wkt_str += f", ({' ,'.join([f'{x} {y}' for x, y in hole])})"
    
    wkt_str += ")"
    return wkt_str

def genCase5(bbox):
    """Case 5: Simple multipolygon with one extra polygon."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Split the bbox into two parts
    bbox1 = [min_x, min_y, min_x + width/2 - width*0.05, max_y]
    bbox2 = [min_x + width/2 + width*0.05, min_y, max_x, max_y]
    
    poly1 = generate_random_polygon(bbox1, 5)
    poly2 = generate_random_polygon(bbox2, 5)
    
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in poly1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly2])})))"
    
    return wkt_str

def genCase6(bbox, num_extra_polygons=2):
    """Case 6: Simple multipolygon with two or more extra polygons."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Divide the bbox into a grid
    grid_size = math.ceil(math.sqrt(num_extra_polygons + 1))
    cell_width = width / grid_size
    cell_height = height / grid_size
    
    polygons = []
    for i in range(num_extra_polygons + 1):
        row = i // grid_size
        col = i % grid_size
        
        # Calculate cell bbox
        cell_bbox = [
            min_x + col * cell_width, 
            min_y + row * cell_height,
            min_x + (col + 0.8) * cell_width,  # Make cells smaller to ensure separation
            min_y + (row + 0.8) * cell_height
        ]
        
        polygons.append(generate_random_polygon(cell_bbox, random.randint(4, 7)))
    
    wkt_str = "MULTIPOLYGON ("
    wkt_parts = []
    for poly in polygons:
        wkt_parts.append(f"(({' ,'.join([f'{x} {y}' for x, y in poly])}))")
    wkt_str += ", ".join(wkt_parts) + ")"
    
    return wkt_str

def genCase7(bbox):
    """Case 7: Simple multipolygon with one polygon having a hole."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create two separate bboxes
    bbox1 = [min_x, min_y, min_x + width/2 - width*0.05, max_y]
    bbox2 = [min_x + width/2 + width*0.05, min_y, max_x, max_y]
    
    # First polygon with a hole
    outer_ring1 = generate_random_polygon(bbox1, 6)
    poly1 = Polygon(outer_ring1)
    hole1 = generate_random_hole(poly1)
    
    # Second simple polygon
    poly2 = generate_random_polygon(bbox2, 5)
    
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in outer_ring1])}), "
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly2])})))"
    
    return wkt_str

def genCase8(bbox, num_holes=2):
    """Case 8: Simple multipolygon with multiple polygons having holes."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create two separate bboxes
    bbox1 = [min_x, min_y, min_x + width/2 - width*0.05, max_y]
    bbox2 = [min_x + width/2 + width*0.05, min_y, max_x, max_y]
    
    # First polygon with holes
    outer_ring1 = generate_random_polygon(bbox1, 6)
    poly1 = Polygon(outer_ring1)
    holes1 = [generate_random_hole(poly1, 
                                 min_radius_ratio=0.1 + (i * 0.05), 
                                 max_radius_ratio=0.2 + (i * 0.05)) 
              for i in range(num_holes)]
    
    # Second polygon with hole
    outer_ring2 = generate_random_polygon(bbox2, 6)
    poly2 = Polygon(outer_ring2)
    hole2 = generate_random_hole(poly2)
    
    # Build WKT string
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in outer_ring1])})"
    for hole in holes1:
        wkt_str += f", ({' ,'.join([f'{x} {y}' for x, y in hole])})"
    wkt_str += "), "
    
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in outer_ring2])}), "
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole2])})))"
    
    return wkt_str

def genCase9(bbox):
    """Case 9: Polygon with concave shape."""
    concave_poly = generate_concave_polygon(bbox)
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in concave_poly])}))"

def genCase10(bbox):
    """Case 10: Self-touching polygon (bowtie)."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    center_x = min_x + width / 2
    center_y = min_y + height / 2
    
    # Create a bowtie shape - this is an invalid polygon according to OGC spec but included for testing
    points = [
        (center_x - width * 0.3, center_y - height * 0.3),
        (center_x + width * 0.3, center_y + height * 0.3),
        (center_x - width * 0.3, center_y + height * 0.3),
        (center_x + width * 0.3, center_y - height * 0.3),
        (center_x - width * 0.3, center_y - height * 0.3)  # Close the polygon
    ]
    
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in points])}))"

def genCase11(bbox):
    """Case 11: Polygon with collinear points."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create a polygon with collinear points
    points = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.4, min_y + height * 0.2),  # Collinear point
        (min_x + width * 0.6, min_y + height * 0.2),  # Collinear point
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.2, min_y + height * 0.2)   # Close the polygon
    ]
    
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in points])}))"

def genCase12(bbox):
    """Case 12: Adjacent polygons touching at a point."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    center_x = min_x + width / 2
    center_y = min_y + height / 2
    
    # Create two polygons that touch at a single point
    poly1 = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (center_x, center_y),  # Touching point
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.2, min_y + height * 0.2)  # Close the polygon
    ]
    
    poly2 = [
        (center_x, center_y),  # Touching point
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.8, min_y + height * 0.8),
        (center_x, center_y)   # Close the polygon
    ]
    
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in poly1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly2])})))"
    
    return wkt_str

def genCase13(bbox):
    """Case 13: Adjacent polygons touching along an edge."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create two polygons that share an edge
    poly1 = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.5, min_y + height * 0.2),
        (min_x + width * 0.5, min_y + height * 0.8),  # Shared edge
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.2, min_y + height * 0.2)   # Close the polygon
    ]
    
    poly2 = [
        (min_x + width * 0.5, min_y + height * 0.2),
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.5, min_y + height * 0.8),  # Shared edge
        (min_x + width * 0.5, min_y + height * 0.2)   # Close the polygon
    ]
    
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in poly1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly2])})))"
    
    return wkt_str

def genCase14(bbox):
    """Case 14: Polygon with spike (narrow protrusion)."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create a polygon with a spike
    points = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.6, min_y + height * 0.2),
        (min_x + width * 0.6, min_y - height * 0.2),  # Spike point
        (min_x + width * 0.4, min_y - height * 0.2),  # Spike point
        (min_x + width * 0.4, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.2)   # Close the polygon
    ]
    
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in points])}))"

def genCase15(bbox):
    """Case 15: Polygon with very small hole."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    center_x = min_x + width / 2
    center_y = min_y + height / 2
    
    # Create outer ring
    outer_ring = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.2)   # Close the polygon
    ]
    
    # Create a tiny hole
    small_radius = min(width, height) * 0.02
    hole = generate_regular_polygon(center_x, center_y, small_radius, 4)
    
    wkt_str = f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in outer_ring])}), "
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole])}))"
    
    return wkt_str

def genCase16(bbox):
    """Case 16: Polygon with hole close to outer boundary."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create outer ring
    outer_ring = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.2)   # Close the polygon
    ]
    
    # Create a hole very close to one edge
    edge_x = min_x + width * 0.21  # Very close to the left edge
    edge_y = min_y + height * 0.5
    hole_radius = min(width, height) * 0.05
    hole = generate_regular_polygon(edge_x, edge_y, hole_radius, 5)
    
    wkt_str = f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in outer_ring])}), "
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole])}))"
    
    return wkt_str

def genCase17(bbox):
    """Case 17: Polygon with extreme aspect ratio (very narrow)."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create a very narrow polygon
    narrow_height = height * 0.02
    
    points = [
        (min_x + width * 0.2, min_y + height * 0.5 - narrow_height/2),
        (min_x + width * 0.8, min_y + height * 0.5 - narrow_height/2),
        (min_x + width * 0.8, min_y + height * 0.5 + narrow_height/2),
        (min_x + width * 0.2, min_y + height * 0.5 + narrow_height/2),
        (min_x + width * 0.2, min_y + height * 0.5 - narrow_height/2)  # Close the polygon
    ]
    
    return f"POLYGON (({' ,'.join([f'{x} {y}' for x, y in points])}))"

def genCase18(bbox):
    """Case 18: MultiPolygon with significantly different sized polygons."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Create a large polygon
    large_poly = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.8),
        (min_x + width * 0.8, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.2)  # Close the polygon
    ]
    
    # Create a tiny polygon
    center_x = min_x + width * 0.9
    center_y = min_y + height * 0.9
    small_radius = min(width, height) * 0.02
    small_poly = generate_regular_polygon(center_x, center_y, small_radius, 4)
    
    wkt_str = f"MULTIPOLYGON ((({' ,'.join([f'{x} {y}' for x, y in large_poly])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in small_poly])})))"
    
    return wkt_str

def genCase19(bbox):
    """Case 19: Complex MultiPolygon with holes and islands."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # First polygon with a hole
    outer_ring1 = [
        (min_x + width * 0.1, min_y + height * 0.1),
        (min_x + width * 0.1, min_y + height * 0.4),
        (min_x + width * 0.4, min_y + height * 0.4),
        (min_x + width * 0.4, min_y + height * 0.1),
        (min_x + width * 0.1, min_y + height * 0.1)  # Close the polygon
    ]
    
    hole1 = [
        (min_x + width * 0.2, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.3),
        (min_x + width * 0.3, min_y + height * 0.3),
        (min_x + width * 0.3, min_y + height * 0.2),
        (min_x + width * 0.2, min_y + height * 0.2)  # Close the hole
    ]
    
    # Second polygon (island inside the hole of first)
    island = [
        (min_x + width * 0.22, min_y + height * 0.22),
        (min_x + width * 0.22, min_y + height * 0.28),
        (min_x + width * 0.28, min_y + height * 0.28),
        (min_x + width * 0.28, min_y + height * 0.22),
        (min_x + width * 0.22, min_y + height * 0.22)  # Close the island
    ]
    
    # Third polygon
    poly3 = [
        (min_x + width * 0.6, min_y + height * 0.6),
        (min_x + width * 0.6, min_y + height * 0.9),
        (min_x + width * 0.9, min_y + height * 0.9),
        (min_x + width * 0.9, min_y + height * 0.6),
        (min_x + width * 0.6, min_y + height * 0.6)  # Close the polygon
    ]
    
    wkt_str = "MULTIPOLYGON ("
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in outer_ring1])}), " 
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in island])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly3])})))"
    
    return wkt_str

def genCase20(bbox):
    """Case 20: MultiPolygon with nested polygons (island within lake within island)."""
    min_x, min_y, max_x, max_y = bbox
    width = max_x - min_x
    height = max_y - min_y
    
    # Outer polygon
    outer_ring = [
        (min_x + width * 0.1, min_y + height * 0.1),
        (min_x + width * 0.1, min_y + height * 0.9),
        (min_x + width * 0.9, min_y + height * 0.9),
        (min_x + width * 0.9, min_y + height * 0.1),
        (min_x + width * 0.1, min_y + height * 0.1)  # Close the polygon
    ]
    
    # First hole (lake)
    hole = [
        (min_x + width * 0.3, min_y + height * 0.3),
        (min_x + width * 0.3, min_y + height * 0.7),
        (min_x + width * 0.7, min_y + height * 0.7),
        (min_x + width * 0.7, min_y + height * 0.3),
        (min_x + width * 0.3, min_y + height * 0.3)  # Close the hole
    ]

    wkt_str = "MULTIPOLYGON ("
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in outer_ring1])}), " 
    wkt_str += f"({' ,'.join([f'{x} {y}' for x, y in hole1])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in island])})), "
    wkt_str += f"(({' ,'.join([f'{x} {y}' for x, y in poly3])})))"
    
    return wkt_str

## USER GLOBAL VARIABLES
INPUT_BBOX = [11.360694444453532, 48.06152777781623, 11.723194444453823, 48.24819444448305]
NUM_OF_POINTS = 10  # 1,2 points are not polygon, so start with atleast 3 points 
NUM_OF_HOLES = 100
PERCENTAGE_OF_AREA = 1.0

for i in range(3, NUM_OF_POINTS):
    polygon = genCase1(INPUT_BBOX, NUM_OF_POINTS)
    print(f"Points: {i} - {polygon}")